#include "filtroSonidos.h"

using namespace std;

double dameNormal( double mu, double sigma )
{	
	double r = ((double) rand() / (RAND_MAX));
	double r2 = ((double) rand() / (RAND_MAX));
	double rn = sqrt( -2.* log(r) )*cos(2.*PI*r2);
	
	return	rn*sigma + mu;
}

FiltroSonidos::FiltroSonidos(int tam, double range)
{
	rango = range;
	srand( time(NULL) );

	int i,j;
	MT = new Matriz<double>(tam,tam);
	
	double tam_d = (double) tam;

	for ( i=0 ; i<tam ; ++i ) {

		double C = ( i==0 ) ? sqrt(1.f/tam_d) : sqrt(2.f/tam_d);

		for ( j=0 ; j<tam ; ++j ) {

			double tmp = C*cos( ( 0.5 + j ) * i * PI / tam_d );
			(*MT)[i][j]  = floor(rango*tmp + 1.)/2 ;
		}
	}
}

FiltroSonidos::~FiltroSonidos(){
	delete MT;
}


void FiltroSonidos::ruido_normal( Matriz<double> &entrada, double escala ){

	#if DEBUG
	Matriz<double> coef( entrada.cantFil(), entrada.cantCol() );
	coef.cargarMultiplicacion( *MT, entrada );
	coef.guardarArchivo( "coef1" );
	#endif

	for(int i=0; i<entrada.cantFil();i++){
		double r = dameNormal(-0.5f,0.5f)*escala;
		entrada[i][0] = (entrada[i][0] + r); 
	}
}

void FiltroSonidos::ruido_sltpap( Matriz<double> &entrada, int max ){

	#if DEBUG
	Matriz<double> coef( entrada.cantFil(), entrada.cantCol() );
	coef.cargarMultiplicacion( *MT, entrada );
	coef.guardarArchivo( "coef1" );
	#endif


	for(int i=0; i<entrada.cantFil();i++){
		double r = ((double) rand() / (RAND_MAX));
		if( r < 0.15 ){	entrada[i][0] = 0;  }
		if( r > 0.85 ){	entrada[i][0] = max; }
	}
}

void FiltroSonidos::ruido_mult( Matriz<double> &entrada ){

	#if DEBUG
	Matriz<double> coef( entrada.cantFil(), entrada.cantCol() );
	coef.cargarMultiplicacion( *MT, entrada );
	coef.guardarArchivo( "coef1" );
	#endif


	for(int i=0; i<entrada.cantFil();i++){

		double r1 = dameNormal(0,1);
		double r2 = dameNormal(0,1);

		double rn = sqrt( r1*r1 + r2*r2 );

		entrada[i][0] = entrada[i][0]*rn;
	}
}


void FiltroSonidos::denoiser_umbral( Matriz<double> &senal, double umbral_dB, double reduccion)
{

	double umbral = pow(10.f, umbral_dB);
	
	int n = senal.cantFil();

	Matriz<double> matCoef(n,1);
	matCoef.cargarMultiplicacion(*MT,senal);

	#if DEBUG
	//matCoef.guardarArchivo("coef2");
	#endif


	int i,j;

	for ( i=0; i<n ; ++i ) {
		matCoef[i][0] = ( fabs(matCoef[i][0]) >= umbral) ? matCoef[i][0] : matCoef[i][0]*reduccion;
	}

	MT->Gauss( matCoef, senal );
}

void FiltroSonidos::denoiser_sacoFrecAltas( Matriz<double> &senal, double porcentaje, double reduccion )
{
	int n = senal.cantFil();

	int i;

	Matriz<double> matCoef(n,1);
	Matriz<double> P(n,n);
	Matriz<double> L(n,n);
	Matriz<double> U(n,n);
	matCoef.cargarMultiplicacion(*MT,senal);

	#if DEBUG
	//matCoef.guardarArchivo("coef2");
	#endif

	int puntoDeCorteI = (porcentaje / 100.f) * n;

	for( i=0; i<n ; ++i ) {
		matCoef[i][0] = ( i <= puntoDeCorteI  ) ? matCoef[i][0] : matCoef[i][0]*reduccion ;
	}

	MT->Gauss( matCoef, senal );
	
}

/* DEBUG - NO ELIMINAR */

void FiltroSonidos::transfSenalCoef( Matriz<double> &senal, Matriz<double> &coef ){ coef.cargarMultiplicacion( *MT, senal ); }

void FiltroSonidos::transfCoefSenal( Matriz<double> &coef, Matriz<double> &senal ){ MT->Gauss( coef, senal ); }

